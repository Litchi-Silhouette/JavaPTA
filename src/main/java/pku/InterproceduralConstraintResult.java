package pku;

import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import pascal.taie.ir.stmt.*;
import pascal.taie.World;
import pascal.taie.language.classes.ClassHierarchy;
import pascal.taie.language.classes.JClass;
import pascal.taie.language.classes.JMethod;
import pascal.taie.ir.IR;
import pascal.taie.ir.proginfo.MemberRef;
import pascal.taie.ir.proginfo.MethodRef;
import pascal.taie.ir.exp.*;
import pascal.taie.ir.exp.Var;
import pascal.taie.util.collection.Maps;
import pascal.taie.util.collection.TwoKeyMap;

import pku.abs.*;
import pku.constraint.*;

public class InterproceduralConstraintResult {

    private TwoKeyMap<JClass, MemberRef, Set<JMethod>> resolveTable;
    public ConstraintSet constraintSet;

    public InterproceduralConstraintResult() {
        resolveTable = Maps.newTwoKeyMap();
        constraintSet = new ConstraintSet();
    }

    /**
     * Add method constraints and invoke constraints to interprocedural constraint set, and update the worklist with new contexts generated by invoke statements.
     * 
     * @param mcr the method constraint result to be merged
     * @param callerContextId the context id of the caller, to be used as context id for the arguments and return value
     * @param workList the worklist for the interprocedural analysis, to be updated with new contexts by invoke statements
     * 
     */

    public void updateInterprocedualConstraint(MethodConstraintResult mcr, int callerContextId, List<Context> workList) {
        // merge the constraint set
        this.constraintSet.addConstraintSet(mcr.constraintSet);
        AbstractVarDomain domain = mcr.domain;

        for (Invoke invoke : mcr.invokeStmts) {
            InvokeExp invokeExp = invoke.getInvokeExp();
            
            // resolve the target methods
            Set<JMethod> targetMethods = resolveTargetMethods(invokeExp);
            for (JMethod targetMethod : targetMethods) {
                // for each target method, create a new context and add it to the worklist
                IR ir = targetMethod.getIR();
                Context invokeContext = new Context(invoke, ir);
                int calleeContextId = invokeContext.hashCode();
                workList.add(invokeContext);

                // add constraints for the invoke statement
                // add constraints for the arguments: paramVar <- argVar
                List<Var> args = invokeExp.getArgs();
                for (int i = 0; i < args.size(); i++) {
                    var argVar = new AbstractVar(callerContextId, args.get(i), null);
                    var paramVar = new AbstractVar(calleeContextId, ir.getParam(i), null);
                    Integer argId = domain.getVarIndex(argVar);
                    Integer paramId = domain.checkAndAdd(paramVar);
                    if (argId == -1) {
                        System.err.println("argVar not defined: " + argVar);
                        argId = domain.addVar(argVar);
                    }
                    constraintSet.addSimpleSConstraint(new SimpleSConstraint(paramId, argId));
                }

                // add constraints for the return value: resultVar <- returnVar
                Var result = invoke.getResult();
                if (result != null) {
                    var resultVar = new AbstractVar(callerContextId, result, null);
                    var resultId = domain.getVarIndex(resultVar);
                    if (resultId == -1) {
                        System.err.println("resultVar not defined: " + resultVar);
                        resultId = domain.addVar(resultVar);
                    }
                    List<Var> returnVars = ir.getReturnVars();
                    for (Var ret : returnVars) {
                        var returnVar = new AbstractVar(calleeContextId, ret, null);
                        var returnId = domain.checkAndAdd(returnVar);
                        constraintSet.addSimpleSConstraint(new SimpleSConstraint(resultId, returnId));
                    }
                }
            }
        }
    };

    /**
     * Resolve all possible target methods of an invoke expression.
     * 
     * @param invoke the invoke expression
     * @return a set of target methods
     * 
     */
    private Set<JMethod> resolveTargetMethods(InvokeExp invoke) {
        ClassHierarchy hierarchy = World.get().getClassHierarchy();

        if (invoke instanceof InvokeVirtual || invoke instanceof InvokeInterface) {
            MethodRef methodRef = invoke.getMethodRef();
            JClass cls = methodRef.getDeclaringClass();
            Set<JMethod> callees = resolveTable.get(cls, methodRef);
            if (callees == null) {
                callees = hierarchy.getAllSubclassesOf(cls)
                        .stream()
                        .filter(Predicate.not(JClass::isAbstract))
                        .map(c -> hierarchy.dispatch(c, methodRef))
                        .filter(Objects::nonNull)
                        .collect(Collectors.toUnmodifiableSet());
                resolveTable.put(cls, methodRef, callees);
            }
            return callees;
        }else if (invoke instanceof InvokeSpecial || invoke instanceof InvokeStatic) {
            return Set.of(invoke.getMethodRef().resolve());
        } else {
            // add a warning here for unsupported invoke type: DynamicInvoke
            System.err.println("Unsupported invoke type: InvokeDynamic");
            return Set.of();
        }
    }
}
