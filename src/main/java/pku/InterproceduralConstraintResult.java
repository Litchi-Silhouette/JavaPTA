package pku;

import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import pascal.taie.ir.stmt.*;
import pascal.taie.World;
import pascal.taie.language.classes.ClassHierarchy;
import pascal.taie.language.classes.JClass;
import pascal.taie.language.classes.JMethod;
import pascal.taie.ir.IR;
import pascal.taie.ir.proginfo.MemberRef;
import pascal.taie.ir.proginfo.MethodRef;
import pascal.taie.ir.exp.*;
import pascal.taie.ir.exp.Var;
import pascal.taie.util.collection.Maps;
import pascal.taie.util.collection.TwoKeyMap;

import pku.abs.*;
import pku.constraint.*;

public class InterproceduralConstraintResult {

    private TwoKeyMap<JClass, MemberRef, Set<JMethod>> resolveTable;
    public ConstraintSet constraintSet;

    public InterproceduralConstraintResult() {
        this.resolveTable = Maps.newTwoKeyMap();
        this.constraintSet = new ConstraintSet();
    }

    /**
     * Add method constraints and invoke constraints to interprocedural constraint
     * set, and update the worklist with new contexts generated by invoke
     * statements.
     * 
     * @param mcr             the method constraint result to be merged
     * @param callerContextId the context id of the caller, to be used as context id
     *                        for the arguments and return value
     * @param workList        the worklist for the interprocedural analysis, to be
     *                        updated with new contexts by invoke statements
     * 
     */

    public void updateInterprocedualConstraint(MethodConstraintResult mcr, int callerContextId,
            List<Context> workList) {
        // merge the constraint set
        this.constraintSet.addConstraintSet(mcr.constraintSet);
        AbstractVarDomain domain = mcr.domain;

        for (Invoke invoke : mcr.invokeStmts) {
            // boolean isSuper = Context.isSuper(invoke);
            // if (isSuper) {
            //     System.out.println("[Inter][invoke] Super call");
            // }
            InvokeExp invokeExp = invoke.getInvokeExp();
            boolean isInstance = invokeExp instanceof InvokeInstanceExp ? true : false;
            int baseVarId = -1;
            String baseVarName = "";
            System.out.println("----------------------------------");
            System.out.println("[Inter][invoke] "+invokeExp);

            // add constraints for the `base.f()` expression
            // let this = base
            if (isInstance) {
                Var base = ((InvokeInstanceExp) invokeExp).getBase();
                var baseVar = new AbstractVar(callerContextId, base, null);
                baseVarId = domain.getVarIndex(baseVar);
                if (baseVarId == -1) {
                    System.err.println("baseVar not defined: " + baseVar);
                    baseVarId = domain.addVar(baseVar, null);
                }
                baseVarName = base.getName();
                System.out.println("[Inter] baseVar "+base.getName()+"_"+baseVarId);
            } else {
                System.out.println("[Inter] Not an instance invoke");
            }

            Var result = invoke.getResult();
            if (result != null) {
                var resultVar = new AbstractVar(callerContextId, result, null);
                var resultId = domain.getVarIndex(resultVar);
                if (resultId == -1) {
                    System.err.println("resultVar not defined: " + resultVar);
                    resultId = domain.addVar(resultVar, null);
                }
                System.out.println("[Inter] resultVar "+result.getName()+"_"+resultId);
            }else{
                System.out.println("[Inter] No result");
            }

            // resolve the target methods
            Set<JMethod> targetMethods = resolveTargetMethods(invokeExp);
            if (targetMethods.isEmpty()) {
                System.err.println("[Inter][!] No target method found for invoke: " + invokeExp);
                continue;
            }
            for (JMethod targetMethod : targetMethods) {
                // for each target method, create a new context and add it to the worklist

                if (targetMethod.getDeclaringClass().getName().equals("java.lang.Object")
                        || targetMethod.getDeclaringClass().getName().equals("java.lang.ObjectN")) {
                    if (targetMethod.isConstructor()) {
                        // skip the Object.init() method
                        continue;
                    }
                }
                
                System.out.println("[Inter] targetMethod "+targetMethod.getName()+" "+targetMethod.getSignature());
                IR ir = targetMethod.getIR();
                if (ir == null) {
                    System.err.println("IR not found for method: " + targetMethod.getName());
                    continue;
                }

                Context invokeContext = new Context(invoke, ir, callerContextId);
                int calleeContextId = invokeContext.hashCode();
                workList.add(invokeContext);

                // add constraints for the invoke statement

                // 1. add constraints for this = base
                if (isInstance && ir.getThis() != null) {
                    var thisVar = new AbstractVar(calleeContextId, ir.getThis(), null);
                    int thisVarId = domain.checkAndAdd(thisVar);
                    constraintSet.addSimpleSConstraint(new SimpleSConstraint(thisVarId, baseVarId));

                    // if the target method is a constructor, then base = this
                    // because `this` in the context is unique for each `base`
                    if (targetMethod.isConstructor()) {
                        constraintSet.addSimpleSConstraint(new SimpleSConstraint(baseVarId, thisVarId));
                    }
                    System.out.println("[Inter] 1. thisVar " + ir.getThis().getName() + "_" + thisVarId + " = baseVar "
                            + baseVarName + "_" + baseVarId);
                }

                // 2. add constraints for the arguments: paramVar = argVar
                List<Var> args = invokeExp.getArgs();
                for (int i = 0; i < args.size(); i++) {
                    var argVar = new AbstractVar(callerContextId, args.get(i), null);
                    var paramVar = new AbstractVar(calleeContextId, ir.getParam(i), null);
                    Integer argId = domain.getVarIndex(argVar);
                    Integer paramId = domain.checkAndAdd(paramVar);
                    if (argId == -1) {
                        System.err.println("argVar not defined: " + argVar);
                        argId = domain.addVar(argVar, null);
                    }
                    constraintSet.addSimpleSConstraint(new SimpleSConstraint(paramId, argId));
                    System.out.println("[Inter] 2. paramVar " + ir.getParam(i).getName() + "_" + paramId + " = argVar " + args.get(i).getName() + "_" + argId);
                }

                // 3. add constraints for the return value: resultVar = returnVar
                if (result != null) {
                    var resultVar = new AbstractVar(callerContextId, result, null);
                    var resultId = domain.getVarIndex(resultVar);
                    if (resultId == -1) {
                        System.err.println("resultVar not defined: " + resultVar);
                        resultId = domain.addVar(resultVar, null);
                    }
                    List<Var> returnVars = ir.getReturnVars();
                    for (Var ret : returnVars) {
                        var returnVar = new AbstractVar(calleeContextId, ret, null);
                        var returnId = domain.checkAndAdd(returnVar);
                        constraintSet.addSimpleSConstraint(new SimpleSConstraint(resultId, returnId));
                        System.out.println("[Inter] 3. resultVar " + result.getName() + "_" + resultId + " = returnVar " + ret.getName() + "_" + returnId);
                    }
                }
            }
        }
    };

    /**
     * Resolve all possible target methods of an invoke expression.
     * 
     * @param invoke the invoke expression
     * @return a set of target methods
     * 
     */
    private Set<JMethod> resolveTargetMethods(InvokeExp invoke) {
        ClassHierarchy hierarchy = World.get().getClassHierarchy();

        if (invoke instanceof InvokeVirtual || invoke instanceof InvokeInterface) {
            MethodRef methodRef = invoke.getMethodRef();
            JClass cls = methodRef.getDeclaringClass();
            Set<JMethod> callees = resolveTable.get(cls, methodRef);
            if (callees == null) {
                callees = hierarchy.getAllSubclassesOf(cls)
                        .stream()
                        .filter(Predicate.not(JClass::isAbstract))
                        .map(c -> hierarchy.dispatch(c, methodRef))
                        .filter(Objects::nonNull)
                        .collect(Collectors.toUnmodifiableSet());
                resolveTable.put(cls, methodRef, callees);
            }
            return callees;
        } else if (invoke instanceof InvokeSpecial || invoke instanceof InvokeStatic) {
            return Set.of(invoke.getMethodRef().resolve());
        } else {
            // add a warning here for unsupported invoke type: DynamicInvoke
            System.err.println("Unsupported invoke type: InvokeDynamic");
            return Set.of();
        }
    }
}
